import sys
import dbus
import dbus.service
import dbus.mainloop.glib
from gi.repository import GLib
from gpiozero import OutputDevice
import json
import time
import os

# --- CONSTANTS ---
DBUS_OM_IFACE = 'org.freedesktop.DBus.ObjectManager'
DBUS_PROP_IFACE = 'org.freedesktop.DBus.Properties'
GATT_MANAGER_IFACE = 'org.bluez.GattManager1'
GATT_CHRC_IFACE = 'org.bluez.GattCharacteristic1'
GATT_SERVICE_IFACE = 'org.bluez.GattService1'
LE_ADVERTISEMENT_IFACE = 'org.bluez.LEAdvertisement1'
LE_ADVERTISING_MANAGER_IFACE = 'org.bluez.LEAdvertisingManager1'

# --- CONFIGURATION ---
REGATTA_SERVICE_UUID = '00000001-710e-4a5b-8d75-3e5b444bc3cf'
RX_UUID              = '00000002-710e-4a5b-8d75-3e5b444bc3cf'
TX_UUID              = '00000003-710e-4a5b-8d75-3e5b444bc3cf'

# Hardware
RELAY_PIN = 17
try:
    relay = OutputDevice(RELAY_PIN, active_high=False, initial_value=False)
except:
    relay = None

# --- LOGIC ---
class RegattaLogic:
    def __init__(self):
        self.countdown_active = False
        self.time_left = 0
        self.tx_callback = None 

    def trigger_relay(self, duration=1.0):
        print(f"!!! HORN BLAST ({duration}s) !!!")
        if relay:
            try:
                relay.on()
                time.sleep(duration)
                relay.off()
            except: pass

    def log_event(self, event_type, details):
        ts = time.strftime("%Y-%m-%d %H:%M:%S")
        entry = f"{ts},{event_type},{details}\n"
        print(f"LOG: {entry.strip()}")
        try:
            with open("race_log.csv", "a") as f: f.write(entry)
        except: pass

    def send_log_file(self):
        """Reads the log file and sends it in chunks via notification"""
        if not self.tx_callback: return
        print("Sending Log File...")
        
        try:
            if not os.path.exists("race_log.csv"):
                self.tx_callback(json.dumps({"log_error": "No log file found"}))
                return

            with open("race_log.csv", "r") as f:
                content = f.read()
            
            # Split into 100-character chunks (safe for BLE)
            chunk_size = 100
            for i in range(0, len(content), chunk_size):
                chunk = content[i:i+chunk_size]
                msg = json.dumps({"log_chunk": chunk})
                self.tx_callback(msg)
                time.sleep(0.05) # Small delay to prevent flooding
            
            # Send End Signal
            self.tx_callback(json.dumps({"log_end": True}))
            print("Log Sent Successfully")
            
        except Exception as e:
            print(f"Log Transfer Error: {e}")
            self.tx_callback(json.dumps({"log_error": str(e)}))

    def tick(self):
        if self.countdown_active and self.time_left > 0:
            self.time_left -= 1
            
            if self.tx_callback:
                try:
                    msg = json.dumps({"time": self.time_left, "status": "Running"})
                    self.tx_callback(msg)
                except: pass

            # Physical Signals
            if self.time_left == 300: # 5m
                self.trigger_relay(1)
                self.log_event("Signal", "Warning (5m)")
            elif self.time_left == 240: # 4m
                self.trigger_relay(1)
                self.log_event("Signal", "Prep (4m)")
            elif self.time_left == 60: # 1m
                self.trigger_relay(1.5)
                self.log_event("Signal", "One Min (1m)")
            elif self.time_left == 0: # GO
                self.trigger_relay(1)
                self.log_event("Signal", "START")
                self.countdown_active = False

        return True

    def handle_command(self, cmd_str):
        try:
            data = json.loads(cmd_str)
            print(f"CMD: {data}")
            cmd = data.get('command')
            
            if cmd == "START_SEQUENCE":
                self.time_left = 305
                self.countdown_active = True
                self.trigger_relay(0.2)
            elif cmd == "POSTPONE":
                self.countdown_active = False
                self.trigger_relay(0.3)
                time.sleep(0.2)
                self.trigger_relay(0.3)
                self.log_event("Command", "AP")
            elif cmd == "GET_LOG":
                self.send_log_file()
                
        except: pass

logic = RegattaLogic()

# --- BLUETOOTH ENGINE (Unchanged Standard Boilerplate) ---
class Application(dbus.service.Object):
    def __init__(self, bus):
        self.path = '/'
        self.services = []
        dbus.service.Object.__init__(self, bus, self.path)
    def get_path(self): return dbus.ObjectPath(self.path)
    def add_service(self, service): self.services.append(service)
    @dbus.service.method(DBUS_OM_IFACE, out_signature='a{oa{sa{sv}}}')
    def GetManagedObjects(self):
        response = {}
        for service in self.services:
            response[service.get_path()] = service.get_properties()
            for chrc in service.get_characteristics():
                response[chrc.get_path()] = chrc.get_properties()
        return response

class Service(dbus.service.Object):
    def __init__(self, bus, index, uuid, primary):
        self.path = '/org/bluez/example/service' + str(index)
        self.bus = bus
        self.uuid = uuid
        self.primary = primary
        self.characteristics = []
        dbus.service.Object.__init__(self, bus, self.path)
    def get_properties(self):
        return {
            GATT_SERVICE_IFACE: {
                'UUID': self.uuid, 'Primary': self.primary,
                'Characteristics': dbus.Array([c.get_path() for c in self.characteristics], signature='o')
            }
        }
    def get_path(self): return dbus.ObjectPath(self.path)
    def add_characteristic(self, chrc): self.characteristics.append(chrc)
    def get_characteristics(self): return self.characteristics

class Characteristic(dbus.service.Object):
    def __init__(self, bus, index, uuid, flags, service):
        self.path = service.path + '/char' + str(index)
        self.bus = bus
        self.uuid = uuid
        self.service = service
        self.flags = flags
        self.value = []
        self.notifying = False
        dbus.service.Object.__init__(self, bus, self.path)
    def get_path(self): return dbus.ObjectPath(self.path)
    def get_properties(self):
        return {
            GATT_CHRC_IFACE: {
                'Service': self.service.get_path(), 'UUID': self.uuid, 'Flags': self.flags,
            }
        }
    @dbus.service.method(GATT_CHRC_IFACE, in_signature='a{sv}', out_signature='ay')
    def ReadValue(self, options): return self.value
    @dbus.service.method(GATT_CHRC_IFACE, in_signature='aya{sv}')
    def WriteValue(self, value, options):
        try:
            cmd = bytes(value).decode('utf-8')
            logic.handle_command(cmd)
        except: pass
    @dbus.service.method(GATT_CHRC_IFACE)
    def StartNotify(self):
        self.notifying = True
        logic.tx_callback = self.send_tx
    @dbus.service.method(GATT_CHRC_IFACE)
    def StopNotify(self): self.notifying = False
    def send_tx(self, msg):
        if not self.notifying: return
        value = dbus.Array(msg.encode('utf-8'), signature=dbus.Signature('y'))
        self.PropertiesChanged(GATT_CHRC_IFACE, {'Value': value}, [])
    @dbus.service.signal(DBUS_PROP_IFACE, signature='sa{sv}as')
    def PropertiesChanged(self, interface, changed, invalidated): pass

class Advertisement(dbus.service.Object):
    def __init__(self, bus, index, type):
        self.path = '/org/bluez/example/advertisement' + str(index)
        self.bus = bus
        self.ad_type = type
        self.local_name = 'StartBot'
        self.service_uuids = [REGATTA_SERVICE_UUID]
        dbus.service.Object.__init__(self, bus, self.path)
    def get_path(self): return dbus.ObjectPath(self.path)
    @dbus.service.method(DBUS_PROP_IFACE, in_signature='s', out_signature='a{sv}')
    def GetAll(self, interface):
        if interface != LE_ADVERTISEMENT_IFACE: return {}
        return {
            'Type': self.ad_type,
            'ServiceUUIDs': dbus.Array(self.service_uuids, signature='s'),
            'LocalName': dbus.String(self.local_name),
            'IncludeTxPower': dbus.Boolean(True)
        }
    @dbus.service.method(LE_ADVERTISEMENT_IFACE, signature='', out_signature='')
    def Release(self): print('Advertisement released')

def main():
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
    bus = dbus.SystemBus()
    app = Application(bus)
    srv = Service(bus, 0, REGATTA_SERVICE_UUID, True)
    rx = Characteristic(bus, 0, RX_UUID, ['write'], srv)
    tx = Characteristic(bus, 1, TX_UUID, ['read', 'notify'], srv)
    srv.add_characteristic(rx)
    srv.add_characteristic(tx)
    app.add_service(srv)
    
    adapter = bus.get_object('org.bluez', '/org/bluez/hci0')
    manager = dbus.Interface(adapter, GATT_MANAGER_IFACE)
    manager.RegisterApplication(app.get_path(), {}, reply_handler=lambda:print("GATT OK"), error_handler=lambda e:print(f"GATT Error: {e}"))
    
    ad_manager = dbus.Interface(adapter, LE_ADVERTISING_MANAGER_IFACE)
    ad = Advertisement(bus, 0, 'peripheral')
    ad_manager.RegisterAdvertisement(ad.get_path(), {}, reply_handler=lambda:print("Advertising..."), error_handler=lambda e:print(f"Adv Error: {e}"))

    GLib.timeout_add_seconds(1, logic.tick)
    print("StartBot Running (Log Supported)...")
    mainloop = GLib.MainLoop()
    try: mainloop.run()
    except KeyboardInterrupt: print("\nStopping...")

if __name__ == '__main__':
    main()
