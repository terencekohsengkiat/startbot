<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Regatta Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        :root { --bg-color: #121212; --card-bg: #1e1e1e; --primary: #007bff; --danger: #dc3545; --success: #28a745; --warning: #ffc107; --text-main: #ffffff; --text-dim: #b0b0b0; }
        body { font-family: -apple-system, BlinkMacSystemFont, Roboto, sans-serif; background: var(--bg-color); margin: 0; padding-bottom: 200px; color: var(--text-main); overflow-x: hidden; }
        
        /* HEADER (TIMERS) */
        .sticky-header { position: sticky; top: 0; z-index: 1000; background: #000000; padding: 10px; border-bottom: 1px solid #333; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: center; }
        .timer-box { background: #222; padding: 8px; border-radius: 8px; }
        .timer-val { font-size: 2.2rem; font-weight: bold; font-family: monospace; line-height: 1; }
        .timer-label { font-size: 0.7rem; text-transform: uppercase; color: #888; margin-top: 4px; }
        .timer-green { color: var(--success); }
        .timer-yellow { color: var(--warning); }

        /* BODY (CARDS) */
        .container { padding: 10px; }
        #sequence-stack { display: flex; flex-direction: column; gap: 8px; }
        
        /* CARD STYLES */
        .card { background: var(--card-bg); border-radius: 6px; border-left: 4px solid #555; overflow: hidden; transition: all 0.2s; }
        .card.active { border-left: 8px solid var(--success); background: #2a2a2a; }
        .card.pending { opacity: 0.7; }
        
        .card-header { padding: 12px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .card-info { flex-grow: 1; }
        .card-title { font-weight: bold; font-size: 1rem; }
        .card-status { font-size: 0.8rem; color: var(--warning); font-family: monospace; }
        .card-body { padding: 0 12px 12px 12px; display: none; } /* Collapsed by default */
        .card.expanded .card-body { display: block; }
        
        .drag-handle { color: #666; margin-right: 10px; font-size: 1.2rem; }
        .form-row { margin-bottom: 10px; }
        label { display: block; color: var(--text-dim); font-size: 0.75rem; margin-bottom: 2px; }
        select, input[type="time"] { width: 100%; background: #333; color: white; border: 1px solid #444; padding: 8px; border-radius: 4px; font-size: 0.9rem; }

        /* ADD BUTTONS */
        .add-zone { display: flex; justify-content: center; gap: 10px; margin: 20px 0; }
        .btn-add { width: 40px; height: 40px; border-radius: 50%; border: none; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }

        /* COMMIT BUTTON */
        .commit-zone { padding: 0 10px; margin-bottom: 10px; }
        .btn-commit { width: 100%; padding: 12px; font-size: 1rem; font-weight: bold; border-radius: 6px; border: none; cursor: pointer; text-transform: uppercase; }
        .btn-commit.unlocked { background: var(--primary); color: white; }
        .btn-commit.ready { background: var(--success); color: white; animation: pulse 1.5s infinite; }
        .btn-commit.locked { background: #333; color: #888; cursor: default; }

        /* FOOTER (CONTROLS) */
        .footer-controls { position: fixed; bottom: 0; left: 0; right: 0; background: #000; padding: 10px; border-top: 1px solid #333; z-index: 2000; display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; }
        .btn-foot { height: 60px; border: none; border-radius: 4px; font-weight: bold; font-size: 0.65rem; color: black; text-transform: uppercase; white-space: normal; line-height: 1.1; overflow:hidden; }
        
        .btn-horn { background: var(--warning); grid-column: span 1; }
        .btn-x { background: #17a2b8; color: white; }
        .btn-recall { background: #e83e8c; color: white; }
        .btn-abandon { background: var(--danger); color: white; }
        .btn-ap { background: var(--danger); color: white; border: 2px solid white; }
        .btn-reset { background: #555; color: #aaa; font-size: 0.6rem; }

        /* CONNECT BAR */
        .connect-bar { position: fixed; bottom: 85px; left: 0; right: 0; background: rgba(0,0,0,0.8); padding: 5px 10px; display: flex; justify-content: space-between; align-items: center; z-index: 1900; }
        .status-text { font-size: 0.7rem; color: #666; }
        .status-text.connected { color: var(--success); }
        .btn-connect { background: var(--primary); color: white; border: none; padding: 5px 15px; border-radius: 20px; font-size: 0.8rem; }

        /* MODAL */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 3000; display: none; align-items: center; justify-content: center; }
        .modal { background: #222; padding: 20px; border-radius: 8px; width: 90%; max-width: 350px; text-align: center; }
        .modal h3 { margin-top: 0; color: white; }
        .modal-btns { display: flex; flex-direction: column; gap: 8px; margin-top: 15px; }
        .btn-modal { padding: 12px; background: #444; color: white; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; }
        .btn-modal:active { background: #666; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div class="sticky-header">
        <div class="timer-box">
            <div class="timer-val timer-green" id="mainTimer">00:00</div>
            <div class="timer-label">TO START</div>
        </div>
        <div class="timer-box">
            <div class="timer-val timer-yellow" id="nextSignalTimer">--:--</div>
            <div class="timer-label" id="nextSignalLabel">NEXT EVENT</div>
        </div>
    </div>

    <div class="container">
        <div id="sequence-stack"></div>
        <div class="add-zone">
            <button class="btn-add" onclick="addStartCard()" style="background: var(--primary); color: white;">+</button>
            <button class="btn-add" onclick="addGapCard()" style="background: var(--warning); color: black;">⏳</button>
        </div>
        <div class="commit-zone">
            <button id="btnCommit" class="btn-commit unlocked" onclick="handleCommit()">COMMIT TO SEQUENCE</button>
        </div>
    </div>
    
    <div class="connect-bar">
        <div class="status-text" id="statusText">Disconnected</div>
        <button class="btn-connect" id="btnConnect" onclick="connectBluetooth()">Connect</button>
        <button onclick="downloadLog()" style="background:none;border:1px solid #555;color:#888;border-radius:4px;font-size:0.7rem;padding:2px 6px;">LOG</button>
    </div>

    <div class="footer-controls">
        <button class="btn-foot btn-horn" 
            onpointerdown="manualHorn(true)" 
            onpointerup="manualHorn(false)" 
            onpointerleave="manualHorn(false)"
            oncontextmenu="return false;">HORN</button>
        
        <button class="btn-foot btn-x" onclick="sendXFlag()">X FLAG<br>(1 SND)</button>
        <button class="btn-foot btn-recall" onclick="triggerGenRecall()">GEN<br>RECALL</button>
        <button class="btn-foot btn-abandon" onclick="triggerAbandon()">ABN<br>(RST)</button>
        <button class="btn-foot btn-ap" onclick="triggerAP()">AP<br>(POST)</button>
        <button class="btn-foot btn-reset" onclick="triggerSilentReset()">Silent<br>Reset</button>
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal" id="modalContent"></div>
    </div>

    <script>
        const SERVICE_UUID = '00000001-710e-4a5b-8d75-3e5b444bc3cf';
        const RX_UUID      = '00000002-710e-4a5b-8d75-3e5b444bc3cf';
        const TX_UUID      = '00000003-710e-4a5b-8d75-3e5b444bc3cf';

        let bluetoothDevice, rxCharacteristic;
        let cardIdCounter = 0;
        let logBuffer = "";
        let speechEnabled = false;
        let wakeLock = null;
        
        let isCommitted = false;
        let activeCardIndex = -1;
        
        let gapInterval = null;
        let scheduleInterval = null;
        let currentPiTime = 0; // Tracks Pi time for Waterfall

        // Persistence
        window.addEventListener('load', loadState);

        // --- AUDIO ---
        function speak(text) {
            if (!speechEnabled) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 1.2; 
            window.speechSynthesis.speak(u);
        }

        // --- BLUETOOTH ---
        async function requestWakeLock() { try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){} }
        
        async function connectBluetooth() {
            try {
                speechEnabled = true;
                requestWakeLock();
                speak("System Ready.");
                bluetoothDevice = await navigator.bluetooth.requestDevice({ filters: [{ name: 'StartBot' }], optionalServices: [SERVICE_UUID] });
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                rxCharacteristic = await service.getCharacteristic(RX_UUID);
                const tx = await service.getCharacteristic(TX_UUID);
                await tx.startNotifications();
                tx.addEventListener('characteristicvaluechanged', handleNotifications);
                document.getElementById('statusText').innerText = "Connected";
                document.getElementById('statusText').classList.add("connected");
                document.getElementById('btnConnect').style.display = 'none';
            } catch (e) { alert(e); }
        }

        function onDisconnected() {
            document.getElementById('statusText').innerText = "Disconnected";
            document.getElementById('btnConnect').style.display = 'block';
            speak("Connection Lost");
        }

        function handleNotifications(event) {
            const dataStr = new TextDecoder().decode(event.target.value);
            try {
                const data = JSON.parse(dataStr);
                if (data.log_chunk) logBuffer += data.log_chunk;
                if (data.log_end) saveLogFile();
                
                if (data.time !== undefined) {
                    currentPiTime = data.time;
                    
                    // SYNC LOGIC
                    // If UI thinks it's stopped but Pi is running, try to sync
                    if (!isCommitted && data.status === "Running" && activeCardIndex > -1) {
                         // We found a running state from localStorage, resume it
                         isCommitted = true;
                         document.getElementById('btnCommit').innerText = "LOCKED - SEQUENCE RUNNING";
                         document.getElementById('btnCommit').className = "btn-commit locked";
                         document.querySelectorAll('.card').forEach(c => c.classList.add('locked'));
                    }

                    if (isCommitted) {
                         // Which card is running? The Active One.
                         const cards = document.querySelectorAll('.card');
                         if(activeCardIndex < cards.length) {
                             const card = cards[activeCardIndex];
                             if(card.classList.contains('card-type-start')) {
                                 // We are in a start sequence driven by Pi
                                 updateDashboard(data.time, "pi");
                                 checkVoiceTriggers(data.time);
                             }
                         }
                    }
                }
                
                if (data.status === "Finished") {
                    if (isCommitted) nextCard();
                }
            } catch (e) {}
        }

        async function sendCommand(jsonObj) {
            if (!rxCharacteristic) return;
            await rxCharacteristic.writeValue(new TextEncoder().encode(JSON.stringify(jsonObj)));
        }

        // --- CARD LOGIC ---
        function nextCard() {
            const cards = Array.from(document.querySelectorAll('.card'));
            
            if(activeCardIndex >= 0 && activeCardIndex < cards.length) {
                cards[activeCardIndex].classList.remove('active');
                cards[activeCardIndex].querySelector('.card-status').innerText = "COMPLETED";
            }

            activeCardIndex++;
            saveState(); // Save progress
            
            if (activeCardIndex >= cards.length) {
                setTimeout(() => {
                    speak("Regatta Sequence Complete.");
                    resetUI();
                }, 3000);
                return;
            }
            
            const card = cards[activeCardIndex];
            card.classList.add('active');
            card.classList.add('expanded'); 
            card.scrollIntoView({behavior: "smooth", block: "center"});

            if (card.classList.contains('card-type-start')) executeStartCard(card);
            else executeGapCard(card);
        }

        function executeStartCard(card) {
            const id = card.id.split('-')[1];
            const timeInput = document.getElementById(`time-${id}`).value;
            
            if (activeCardIndex === 0 && timeInput) {
                card.querySelector('.card-status').innerText = `SCHEDULED ${timeInput}`;
                startScheduleWatcher(timeInput);
                speak(`Sequence Armed for ${timeInput}`);
            } else {
                card.querySelector('.card-status').innerText = "RUNNING";
                firePiSequence();
            }
        }

        function executeGapCard(card) {
            const id = card.id.split('-')[1];
            let seconds = parseInt(document.getElementById(`gap-${id}`).value);
            
            if (seconds === 0) { nextCard(); return; }
            
            card.querySelector('.card-status').innerText = "GAP RUNNING";
            speak(`Gap. ${seconds/60} minutes.`);
            
            let gapTime = seconds;
            currentPiTime = seconds; // Simulate Pi time for waterfall
            updateDashboard(gapTime, "gap");
            
            gapInterval = setInterval(() => {
                gapTime--;
                currentPiTime = gapTime;
                updateDashboard(gapTime, "gap");
                
                // GAP VOICE TRIGGERS
                const nextC = document.querySelectorAll('.card')[activeCardIndex + 1];
                let nextMsg = "Next Sequence";
                if(nextC && nextC.classList.contains('card-type-start')) {
                    const nId = nextC.id.split('-')[1];
                    const nClass = document.getElementById(`class-${nId}`).value;
                    nextMsg = (nClass === "None" ? "" : nClass) + " Warning";
                }

                if (gapTime === 60) speak("One minute to " + nextMsg);
                if ([45, 30, 20, 15, 10, 5, 4, 3, 2, 1].includes(gapTime)) {
                     if (gapTime === 10) speak("10 seconds.");
                     else if (gapTime <= 5) speak(gapTime.toString());
                     else speak(`${gapTime} seconds to ${nextMsg}`);
                }

                if (gapTime <= 0) {
                    clearInterval(gapInterval);
                    nextCard();
                }
            }, 1000);
        }

        // --- TIMERS ---
        function startScheduleWatcher(targetTimeStr) {
            if(scheduleInterval) clearInterval(scheduleInterval);
            scheduleInterval = setInterval(() => {
                const now = new Date();
                const target = new Date();
                const [h, m] = targetTimeStr.split(':');
                target.setHours(h, m, 0, 0);
                
                let diff = Math.floor((target - now) / 1000);
                
                if (diff < 0) {
                    clearInterval(scheduleInterval);
                    firePiSequence();
                } else {
                    currentPiTime = diff; // Pseudo-time for waterfall
                    updateDashboard(diff, "preroll");
                    
                    if ([45, 30, 20, 15, 10, 5, 4, 3, 2, 1].includes(diff)) {
                         const id = document.querySelectorAll('.card')[activeCardIndex].id.split('-')[1];
                         const orangeVal = document.getElementById(`orange-${id}`).value;
                         const cls = document.getElementById(`class-${id}`).value;
                         let msg = (orangeVal !== "0") ? "Orange Flag Display" : `${cls} Class Flag Display`;
                         
                         if (diff === 10) speak("10 seconds.");
                         else if(diff <= 5) speak(diff.toString());
                         else speak(`${diff} seconds to ${msg}`);
                     }
                }
            }, 1000);
        }

        function firePiSequence() {
            if(scheduleInterval) clearInterval(scheduleInterval);
            const card = document.querySelectorAll('.card')[activeCardIndex];
            const id = card.id.split('-')[1];
            const orangeVal = document.getElementById(`orange-${id}`).value;
            const cls = document.getElementById(`class-${id}`).value;
            const rule = document.getElementById(`rule-${id}`).value;
            
            const orangeOffset = parseInt(orangeVal) * 60;
            const baseLen = (rule === '3min') ? 180 : 300;
            const duration = baseLen + orangeOffset;
            
            if (orangeOffset > 0) speak("NOW! Orange Flag Display.");
            else speak(`NOW! ${cls} Class Flag Display.`);
            
            sendCommand({ command: 'START_SEQUENCE', seconds: duration, rule: rule });
        }

        // --- DASHBOARD UI & WATERFALL ---
        function updateDashboard(val, mode) {
            const card = document.querySelectorAll('.card')[activeCardIndex];
            if(!card) return;
            const id = card.id.split('-')[1];
            
            // Get Card Config
            const cls = document.getElementById(`class-${id}`).value;
            const prep = document.getElementById(`prep-${id}`).value;
            const rule = document.getElementById(`rule-${id}`).value;
            const orangeVal = document.getElementById(`orange-${id}`).value;
            const orangeOffset = parseInt(orangeVal) * 60;
            const baseLen = (rule === '3min') ? 180 : 300;

            let mainT = 0, subT = 0, label = "";

            if (mode === "gap") {
                mainT = val; subT = val; label = "GAP / ROLLING";
                card.querySelector('.card-status').innerText = `GAP: ${val}s`;
            }
            else if (mode === "preroll") {
                mainT = val + baseLen + orangeOffset;
                subT = val;
                label = (orangeOffset > 0) ? "ORANGE FLAG DISPLAY" : `${cls.toUpperCase()} CLASS FLAG`;
                card.querySelector('.card-status').innerText = `WAITING ${val}s`;
            }
            else if (mode === "pi") {
                mainT = val;
                
                let marks = [];
                if(orangeOffset > 0) marks.push({t: baseLen + orangeOffset, l: "ORANGE FLAG DISPLAY"});
                const r3 = (rule==='3min');
                marks.push({t: r3?180:300, l: `${cls.toUpperCase()} CLASS FLAG`});
                marks.push({t: r3?120:240, l: `${prep.toUpperCase()} FLAG DISPLAY`});
                marks.push({t: 60, l: `${prep.toUpperCase()} FLAG REMOVE`});
                marks.push({t: 0, l: `${cls.toUpperCase()} FLAG REMOVE`});

                let nextObj = marks[marks.length-1];
                for(let m of marks) { if (val > m.t) { nextObj = m; break; } }
                subT = val - nextObj.t;
                label = nextObj.l;
                
                const mM = Math.floor(mainT / 60); const mS = mainT % 60;
                card.querySelector('.card-status').innerText = `RUNNING T-${mM}:${mS.toString().padStart(2,'0')}`;
            }

            const mM = Math.floor(mainT / 60); const mS = mainT % 60;
            document.getElementById('mainTimer').innerText = `${mM}:${mS.toString().padStart(2, '0')}`;
            const sM = Math.floor(subT / 60); const sS = subT % 60;
            document.getElementById('nextSignalTimer').innerText = `${sM}:${sS.toString().padStart(2, '0')}`;
            document.getElementById('nextSignalLabel').innerText = label;
            
            updateWaterfall(mainT);
        }
        
        function updateWaterfall(currentTimeLeft) {
            // Calculate pending cards
            let cumulative = currentTimeLeft;
            const cards = document.querySelectorAll('.card');
            
            for(let i = activeCardIndex + 1; i < cards.length; i++) {
                const c = cards[i];
                const cid = c.id.split('-')[1];
                
                // Determine Duration of THIS pending card to add to stack for NEXT one
                let duration = 0;
                if(c.classList.contains('card-type-start')) {
                    const rule = document.getElementById(`rule-${cid}`).value;
                    const oVal = document.getElementById(`orange-${cid}`).value;
                    duration = (rule==='3min'?180:300) + (parseInt(oVal)*60);
                } else {
                    duration = parseInt(document.getElementById(`gap-${cid}`).value);
                }
                
                // Display Cumulative Time
                const mins = Math.floor(cumulative / 60);
                const secs = cumulative % 60;
                c.querySelector('.card-status').innerText = `STARTS IN ${mins}:${secs.toString().padStart(2,'0')}`;
                
                cumulative += duration;
            }
        }

        function checkVoiceTriggers(t) {
            // Re-read current active card logic for voice triggers
            const id = document.querySelectorAll('.card')[activeCardIndex].id.split('-')[1];
            const cls = document.getElementById(`class-${id}`).value;
            const prep = document.getElementById(`prep-${id}`).value;
            const rule = document.getElementById(`rule-${id}`).value;
            const orangeOffset = parseInt(document.getElementById(`orange-${id}`).value) * 60;
            
            let marks = [];
            const r3 = (rule === '3min');
            marks.push(r3?180:300); marks.push(r3?120:240); marks.push(60); marks.push(0);
            if (orangeOffset > 0) marks.unshift((r3?180:300) + orangeOffset);

            const triggers = [45, 30, 20, 15, 10, 5, 4, 3, 2, 1];

            marks.forEach(mark => {
                const diff = t - mark;
                if (diff >= 0 && diff < 300) {
                    if (diff === 0) {
                         if (mark > (r3?180:300)) speak("NOW! Orange Flag Display.");
                         else if (mark === (r3?180:300)) speak(`NOW! ${cls} Class Flag Display.`);
                         else if (mark === (r3?120:240)) speak(`NOW! ${prep} Flag Display.`);
                         else if (mark === 60) speak(`NOW! ${prep} Flag Remove.`);
                         else if (mark === 0) speak(`NOW! ${cls} Class Flag Remove.`);
                    }
                    if (triggers.includes(diff)) {
                        let eventName = "";
                        if (mark > (r3?180:300)) eventName = "Orange Flag Display";
                        else if (mark === (r3?180:300)) eventName = `${cls} Class Flag Display`;
                        else if (mark === (r3?120:240)) eventName = `${prep} Flag Display`;
                        else if (mark === 60) eventName = `${prep} Flag Remove`;
                        else if (mark === 0) eventName = `${cls} Class Flag Remove`;

                        if (diff === 10) speak("10 seconds.");
                        else if (diff <= 5) speak(diff.toString());
                        else speak(`${diff} seconds to ${eventName}.`);
                    }
                }
            });
        }

        // --- BUTTONS & MODALS ---
        function handleCommit() {
            if(!isCommitted) {
                const btn = document.getElementById('btnCommit');
                const cards = document.querySelectorAll('.card');
                if(cards.length === 0) return;
                const firstId = cards[0].id.split('-')[1];
                const timeInput = document.getElementById(`time-${firstId}`).value;

                if(timeInput) {
                    isCommitted = true;
                    btn.innerText = "LOCKED - SEQUENCE RUNNING";
                    btn.className = "btn-commit locked";
                    lockCards();
                    nextCard();
                } else {
                    if(btn.innerText === "PRESS AGAIN TO START") {
                         isCommitted = true;
                         btn.innerText = "LOCKED - SEQUENCE RUNNING";
                         btn.className = "btn-commit locked";
                         lockCards();
                         nextCard();
                    } else {
                        btn.innerText = "PRESS AGAIN TO START";
                        btn.className = "btn-commit ready";
                    }
                }
            }
        }
        
        function lockCards() { document.querySelectorAll('.card').forEach(c => c.classList.add('locked')); }

        function triggerAbandon() {
            sendCommand({command: 'ABANDON'});
            resetUI();
            speak("Abandon. Abandon.");
        }
        function sendXFlag() { sendCommand({command: 'X_FLAG'}); }
        function triggerSilentReset() {
            sendCommand({command: 'RESET_SILENT'});
            resetUI();
        }
        
        function triggerGenRecall() {
            sendCommand({command: 'GEN_RECALL'});
            showModal("Restart Current Class?", [
                {text: "YES - RESTART", action: () => showRecallTimeOptions()},
                {text: "NO - CONTINUE", action: closeModal}
            ]);
        }
        
        function showRecallTimeOptions() {
            const opts = [
                {text: "1 Minute", action: () => executeRecall(60)},
                {text: "1 Round Min", action: () => executeRecall(calcRoundMin(1))},
                {text: "Cancel", action: closeModal}
            ];
            showModal("Remove 1st Sub In...", opts);
        }
        
        function executeRecall(gapSeconds) {
            closeModal();
            if (gapInterval) clearInterval(gapInterval);
            
            // Clone Active Card Logic
            let cardToCloneIndex = activeCardIndex;
            const cards = document.querySelectorAll('.card');
            // Look backwards for start card
            while(cardToCloneIndex >= 0) {
                 if(cards[cardToCloneIndex].classList.contains('card-type-start')) break;
                 cardToCloneIndex--;
            }
            if(cardToCloneIndex < 0) return; 

            const sourceCard = cards[cardToCloneIndex];
            const id = sourceCard.id.split('-')[1];
            const cloneData = {
                class: document.getElementById(`class-${id}`).value,
                prep: document.getElementById(`prep-${id}`).value,
                rule: document.getElementById(`rule-${id}`).value,
                orange: "0" 
            };
            
            const anchor = cards[activeCardIndex]; 
            const waitCard = createGapElement(gapSeconds, "Waiting to Remove 1st Sub");
            anchor.after(waitCard);
            const ruleGapCard = createGapElement(60, "1 Min Rule (RRS 29.2)");
            waitCard.after(ruleGapCard);
            const startCard = createStartElement(cloneData);
            ruleGapCard.after(startCard);
            
            saveState();
            nextCard(); // Jump to wait gap
        }

        function triggerAP() {
            sendCommand({command: 'POSTPONE'});
            if(gapInterval) clearInterval(gapInterval);
            if(scheduleInterval) clearInterval(scheduleInterval);
            document.body.style.border = "4px solid red";
            
            showModal("Remove AP...", [
                {text: "Select Removal Time & Next Class", action: () => showAPClassSelector()},
                {text: "Cancel / Reset", action: () => resetUI()}
            ]);
        }
        
        function showAPClassSelector() {
            // Build list of start cards
            const cards = Array.from(document.querySelectorAll('.card'));
            let classOpts = [];
            cards.forEach((c, idx) => {
                if(c.classList.contains('card-type-start')) {
                    const id = c.id.split('-')[1];
                    const cls = document.getElementById(`class-${id}`).value;
                    classOpts.push({text: `Start: ${cls}`, idx: idx});
                }
            });
            
            // We need a custom modal content for 2-step choice?
            // Simplified: Just ask "Which Class" then ask "Time".
            const m = document.getElementById('modalContent');
            let html = `<h3>Select Next Class</h3><div class="modal-btns">`;
            classOpts.forEach(o => {
                html += `<button class="btn-modal" onclick="selectAPTime(${o.idx})">${o.text}</button>`;
            });
            html += `</div>`;
            m.innerHTML = html;
        }
        
        function selectAPTime(targetIdx) {
            const m = document.getElementById('modalContent');
            m.innerHTML = `<h3>When to Remove AP?</h3><div class="modal-btns">
                <button class="btn-modal" onclick="executeAPRemoval(${targetIdx}, 60)">1 Minute</button>
                <button class="btn-modal" onclick="executeAPRemoval(${targetIdx}, ${calcRoundMin(1)})">1 Round Min</button>
            </div>`;
        }
        
        function executeAPRemoval(targetIdx, seconds) {
            closeModal();
            document.body.style.border = "none";
            
            // Insert Wait & 1 Min Rule BEFORE the target card
            const cards = document.querySelectorAll('.card');
            const targetCard = cards[targetIdx];
            
            const waitCard = createGapElement(seconds, "Waiting to Remove AP");
            targetCard.before(waitCard);
            const ruleGap = createGapElement(60, "1 Min Rule (AP Removed)");
            targetCard.before(ruleGap); // Inserts before target, but after waitCard? No. before target.
            // insertBefore order matters. target.before(A), target.before(B) -> Result: A, B, Target.
            
            // We need: Wait -> Rule -> Target.
            // DOM: target.before(ruleGap); target.before(waitCard); -> Wait, Rule, Target.
            
            // Reset state
            document.querySelectorAll('.card').forEach(c => {c.classList.remove('active'); c.classList.remove('expanded'); c.classList.add('locked');});
            
            // Set active index to new Wait Card
            // We need to find the index of waitCard now.
            const all = Array.from(document.querySelectorAll('.card'));
            activeCardIndex = all.indexOf(waitCard) - 1; // -1 because nextCard() increments it
            
            isCommitted = true;
            saveState();
            nextCard();
        }

        // --- HELPERS ---
        function calcRoundMin(mins) {
            const now = new Date();
            const s = now.getSeconds();
            return (60 - s) + ((mins - 1) * 60);
        }
        
        function createGapElement(secs, title) {
            const d = document.createElement('div');
            const id = cardIdCounter++;
            d.innerHTML = `
                <div class="card" id="c-${id}" style="border-left-color: #ffc107">
                    <div class="card-header">
                        <div><span class="drag-handle">☰</span><span class="card-title">${title || "Gap"}</span></div>
                        <span class="card-status">PENDING</span>
                    </div>
                    <div class="card-body">
                         <input type="hidden" id="gap-${id}" value="${secs}">
                    </div>
                </div>`;
            return d.firstElementChild;
        }
        
        function createStartElement(data) {
             const d = document.createElement('div');
             const id = cardIdCounter++;
             d.innerHTML = `
                <div class="card card-type-start" id="c-${id}" style="border-left-color: var(--primary)">
                    <div class="card-header">
                        <div><span class="drag-handle">☰</span><span class="card-title">${data.class || "Restart"}</span></div>
                        <span class="card-status">PENDING</span>
                    </div>
                    <div class="card-body">
                        <input type="hidden" id="class-${id}" value="${data.class}">
                        <input type="hidden" id="prep-${id}" value="${data.prep}">
                        <input type="hidden" id="rule-${id}" value="${data.rule}">
                        <input type="hidden" id="orange-${id}" value="${data.orange}">
                        <input type="hidden" id="time-${id}" value="">
                    </div>
                </div>`;
            return d.firstElementChild;
        }

        function showModal(title, buttons) {
            const m = document.getElementById('modalOverlay');
            const c = document.getElementById('modalContent');
            c.innerHTML = `<h3>${title}</h3><div class="modal-btns"></div>`;
            const bDiv = c.querySelector('.modal-btns');
            buttons.forEach(b => {
                const btn = document.createElement('button');
                btn.className = 'btn-modal';
                btn.innerText = b.text;
                btn.onclick = b.action;
                bDiv.appendChild(btn);
            });
            m.style.display = 'flex';
        }
        function closeModal() { document.getElementById('modalOverlay').style.display = 'none'; }

        function resetUI() {
             isCommitted = false; isRunning = false; activeCardIndex = -1;
             if(gapInterval) clearInterval(gapInterval);
             if(scheduleInterval) clearInterval(scheduleInterval);
             localStorage.removeItem('regattaState'); // Clear save
             document.getElementById('btnCommit').innerText = "COMMIT TO SEQUENCE";
             document.getElementById('btnCommit').className = "btn-commit unlocked";
             document.querySelectorAll('.card').forEach(c => {
                 c.classList.remove("locked"); c.classList.remove("active"); c.classList.remove("expanded");
                 c.querySelector('.card-status').innerText = "PENDING";
             });
             sendCommand({ command: 'POSTPONE' }); 
             document.getElementById('mainTimer').innerText = "00:00";
             document.getElementById('nextSignalTimer').innerText = "--:--";
             document.body.style.border = "none";
        }
        
        function manualHorn(state) { state ? sendCommand({ command: 'HORN_ON' }) : sendCommand({ command: 'HORN_OFF' }); }
        function downloadLog() { logBuffer = ""; sendCommand({ command: 'GET_LOG' }); }
        function saveLogFile() {
            const blob = new Blob([logBuffer], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'race_log.csv';
            document.body.appendChild(a); a.click();
        }
        function updateTimeLabel(id) {
            const orangeVal = document.getElementById(`orange-${id}`).value;
            const label = document.getElementById(`time-label-${id}`);
            if (orangeVal === "0") { label.innerText = "Scheduled Warning"; label.style.color = "#b0b0b0"; } 
            else { label.innerText = "Scheduled Orange Flag"; label.style.color = "#ff9800"; }
        }
        
        // PERSISTENCE
        function saveState() {
            const stack = document.getElementById('sequence-stack').innerHTML;
            const state = { html: stack, index: activeCardIndex, committed: isCommitted };
            localStorage.setItem('regattaState', JSON.stringify(state));
        }
        function loadState() {
            const saved = localStorage.getItem('regattaState');
            if(saved) {
                const s = JSON.parse(saved);
                document.getElementById('sequence-stack').innerHTML = s.html;
                activeCardIndex = s.index;
                isCommitted = s.committed;
                // Re-bind sortable events? Sortable handles new DOM elements?
                // Might need to re-init Inputs values since innerHTML doesn't capture value attr changes well.
                // For simplicity, users re-enter if refreshed, but structure remains.
                // Better implementation would map values to objects, but this is a V1 persistence.
            } else {
                addStartCard();
            }
        }

        const stackEl = document.getElementById('sequence-stack');
        new Sortable(stackEl, { handle: '.drag-handle', animation: 150, onEnd: saveState });
        
        stackEl.addEventListener('click', (e) => {
            if(e.target.closest('.card-header')) {
                const c = e.target.closest('.card');
                c.classList.toggle('expanded');
            }
        });
        
        // Inputs change -> Save
        stackEl.addEventListener('change', saveState);

        function addStartCard() {
            const id = cardIdCounter++;
            stackEl.insertAdjacentHTML('beforeend', `
                <div class="card card-type-start" id="c-${id}" style="border-left-color: var(--primary)">
                    <div class="card-header">
                        <div><span class="drag-handle">☰</span><span class="card-title">Start Sequence</span></div>
                        <div style="display:flex;gap:10px;align-items:center;">
                           <span class="card-status">PENDING</span>
                           <button onclick="this.closest('.card').remove(); event.stopPropagation(); saveState();" style="background:none;border:none;color:#666;font-size:1.2rem;">✕</button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="form-row"><label>Sequence Rule</label><select id="rule-${id}"><option value="std">Standard 5-Min (RRS 26)</option><option value="3min">3-Min (Appendix U)</option></select></div>
                        <div class="form-row"><label>Class</label><select id="class-${id}"><option value="None">None (General)</option><option>Optimist Gold</option><option>Optimist Silver</option><option>ILCA 4</option><option>ILCA 6</option><option>ILCA 7</option><option>29er</option><option>49er</option><option>Techno293</option><option>Techno293Plus</option><option>iQ Foil</option><option>WingFoil</option><option>KiteFoil</option></select></div>
                        <div class="form-row"><label>Prep Flag</label><select id="prep-${id}"><option value="P">P (Blue)</option><option value="U">U (Red/White)</option><option value="Black">Black</option></select></div>
                        <div class="form-row"><label style="color:#ff9800">Orange Flag Sound</label><select id="orange-${id}" onchange="updateTimeLabel(${id})"><option value="0">No Orange Flag Needed</option><option value="1">1 Min before Class Flag</option><option value="4">4 Min before Class Flag</option><option value="5">5 Min before Class Flag</option></select></div>
                        <div class="form-row"><label id="time-label-${id}">Scheduled Warning Signal</label><input type="time" id="time-${id}"></div>
                    </div>
                </div>`);
            saveState();
        }
        function addGapCard() {
            const id = cardIdCounter++;
            stackEl.insertAdjacentHTML('beforeend', `
                <div class="card" id="c-${id}" style="border-left-color: #ffc107">
                    <div class="card-header">
                        <div><span class="drag-handle">☰</span><span class="card-title">Gap / AP</span></div>
                         <div style="display:flex;gap:10px;align-items:center;">
                           <span class="card-status">PENDING</span>
                           <button onclick="this.closest('.card').remove(); event.stopPropagation(); saveState();" style="background:none;border:none;color:#666;font-size:1.2rem;">✕</button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="form-row"><label>Duration</label><select id="gap-${id}"><option value="0">Immediate (Rolling)</option><option value="60">1 Min</option><option value="120">2 Min</option><option value="180">3 Min</option><option value="240">4 Min</option><option value="300">5 Min</option><option value="600">10 Min</option></select></div>
                    </div>
                </div>`);
            saveState();
        }
    </script>
</body>
</html>
