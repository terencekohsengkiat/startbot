<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Regatta Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        :root { --bg-color: #1a1a1a; --card-bg: #2d2d2d; --primary: #007bff; --danger: #dc3545; --success: #28a745; --text-main: #ffffff; --text-dim: #b0b0b0; }
        body { font-family: -apple-system, BlinkMacSystemFont, Roboto, sans-serif; background: var(--bg-color); margin: 0; padding-bottom: 160px; color: var(--text-main); }
        
        /* HEADER */
        .sticky-header { position: sticky; top: 0; z-index: 1000; background: #000000; padding: 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; }
        .timers { text-align: left; }
        .main-timer { font-size: 2.5rem; font-weight: bold; font-family: monospace; color: var(--success); line-height: 1; }
        .sub-timer { font-size: 1.2rem; font-family: monospace; color: #ffc107; margin-top: 5px; }
        .sub-label { font-size: 0.7rem; color: #666; text-transform: uppercase; }
        
        .header-controls { display: flex; gap: 8px; }
        .btn-action { padding: 12px 10px; border-radius: 6px; border: none; font-weight: bold; font-size: 0.85rem; cursor: pointer; text-transform: uppercase; color: white; display: flex; align-items: center; justify-content: center; text-align: center;}
        .btn-start { background: var(--success); width: 70px; }
        .btn-ap { background: var(--danger); width: 50px; display: none; }
        .btn-horn { background: #ffc107; color: black; width: 60px; user-select: none; -webkit-user-select: none; touch-action: manipulation; }

        /* CARD STACK */
        .container { padding: 15px; }
        #sequence-stack { display: flex; flex-direction: column; gap: 12px; }
        .card { background: var(--card-bg); border-radius: 8px; padding: 15px; border-left: 5px solid #555; position: relative; transition: opacity 0.3s; }
        .card.locked { opacity: 0.7; pointer-events: none; }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .card-title { font-weight: bold; font-size: 1.1rem; }
        .drag-handle { cursor: grab; color: #666; font-size: 1.5rem; padding-right: 10px; }
        
        .form-row { margin-bottom: 12px; }
        label { display: block; color: var(--text-dim); font-size: 0.8rem; margin-bottom: 4px; }
        select, input[type="time"] { width: 100%; background: #444; color: white; border: 1px solid #555; padding: 10px; border-radius: 6px; font-size: 1rem; box-sizing: border-box; }
        
        /* COMMIT BUTTON */
        .commit-zone { margin-top: 30px; margin-bottom: 20px; }
        .btn-commit { width: 100%; padding: 15px; font-size: 1.1rem; font-weight: bold; border-radius: 8px; border: none; cursor: pointer; transition: all 0.3s; text-transform: uppercase; }
        .btn-commit.unlocked { background: var(--primary); color: white; }
        .btn-commit.locked { background: var(--danger); color: white; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }

        /* ADD BUTTONS */
        .add-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
        .btn-add { width: 50px; height: 50px; border-radius: 50%; border: none; font-size: 1.5rem; cursor: pointer; display: flex; align-items: center; justify-content: center; background: #444; color: white; }

        /* FOOTER */
        .control-bar { position: fixed; bottom: 0; left: 0; right: 0; background: #000; padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #333; z-index: 2000; }
        .status-text { font-size: 0.8rem; color: #666; }
        .status-text.connected { color: var(--success); }
        .btn-connect { background: var(--primary); color: white; border: none; padding: 8px 20px; border-radius: 20px; font-weight: bold; }
        .btn-log { background: transparent; border: 1px solid #666; color: #666; padding: 5px 10px; border-radius: 4px; font-size: 0.8rem; }
    </style>
</head>
<body>

    <div class="sticky-header">
        <div class="timers">
            <div class="main-timer" id="mainTimer">00:00</div>
            <div class="sub-label">Next Signal</div>
            <div class="sub-timer" id="nextSignalTimer">--:--</div>
        </div>
        <div class="header-controls">
            <button class="btn-action btn-horn" id="btnHorn" 
                onpointerdown="manualHorn(true)" 
                onpointerup="manualHorn(false)" 
                onpointerleave="manualHorn(false)"
                oncontextmenu="return false;">HORN</button>
            <button id="btnStart" class="btn-action btn-start" onclick="startNow()">START<br>NOW</button>
            <button id="btnAP" class="btn-action btn-ap" onclick="sendAP()">AP</button>
        </div>
    </div>

    <div class="container">
        <div id="sequence-stack"></div>
        
        <div class="add-buttons">
            <button class="btn-add" onclick="addStartCard()" style="background: var(--primary)">+</button>
            <button class="btn-add" onclick="addGapCard()" style="background: #ffc107; color: black">⏳</button>
        </div>

        <div class="commit-zone">
            <button id="btnCommit" class="btn-commit unlocked" onclick="toggleCommit()">COMMIT TO SEQUENCE</button>
        </div>
    </div>

    <div class="control-bar">
        <div>
            <div class="status-text" id="statusText">Disconnected</div>
            <button class="btn-log" onclick="downloadLog()">Get Log</button>
        </div>
        <button class="btn-connect" id="btnConnect" onclick="connectBluetooth()">Connect</button>
    </div>

    <script>
        const SERVICE_UUID = '00000001-710e-4a5b-8d75-3e5b444bc3cf';
        const RX_UUID      = '00000002-710e-4a5b-8d75-3e5b444bc3cf';
        const TX_UUID      = '00000003-710e-4a5b-8d75-3e5b444bc3cf';

        let bluetoothDevice, rxCharacteristic;
        let cardIdCounter = 0;
        let logBuffer = "";
        let speechEnabled = false;
        let wakeLock = null;
        
        // State
        let isCommitted = false;
        let activeCardIndex = -1;
        let gapInterval = null;
        let scheduleInterval = null;
        
        // Active Card Config
        let currentClass = "";
        let currentPrep = "";
        let orangeOffset = 0; 
        
        // --- WAKE LOCK ---
        async function requestWakeLock() {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                wakeLock.addEventListener('release', () => { console.log('Wake Lock released'); });
            } catch (err) { console.log(`${err.name}, ${err.message}`); }
        }

        // --- AUDIO ENGINE ---
        function speak(text) {
            if (!speechEnabled) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 1.2; 
            window.speechSynthesis.speak(u);
        }

        // --- BLUETOOTH ---
        async function connectBluetooth() {
            try {
                speechEnabled = true;
                requestWakeLock();
                speak("System Ready.");
                bluetoothDevice = await navigator.bluetooth.requestDevice({ filters: [{ name: 'StartBot' }], optionalServices: [SERVICE_UUID] });
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                rxCharacteristic = await service.getCharacteristic(RX_UUID);
                const tx = await service.getCharacteristic(TX_UUID);
                await tx.startNotifications();
                tx.addEventListener('characteristicvaluechanged', handleNotifications);
                
                document.getElementById('statusText').innerText = "Connected";
                document.getElementById('statusText').classList.add("connected");
                document.getElementById('btnConnect').style.display = 'none';
            } catch (e) { alert(e); }
        }

        function onDisconnected() {
            document.getElementById('statusText').innerText = "Disconnected";
            document.getElementById('btnConnect').style.display = 'block';
            speak("Connection Lost");
            resetUI();
        }

        function handleNotifications(event) {
            const dataStr = new TextDecoder().decode(event.target.value);
            try {
                const data = JSON.parse(dataStr);
                if (data.log_chunk) logBuffer += data.log_chunk;
                if (data.log_end) saveLogFile();
                
                if (data.time !== undefined) {
                    // Update UI and check voice for Active Sequence
                    updateTimers(data.time);
                    checkVoiceTriggers(data.time);
                }
                
                // State Management
                if (data.status === "Running") {
                    document.getElementById('btnStart').style.display = 'none';
                    document.getElementById('btnAP').style.display = 'block';
                } else if (data.status === "Finished" || data.status === "Stopped") {
                    document.getElementById('btnStart').style.display = 'block';
                    document.getElementById('btnAP').style.display = 'none';
                    
                    // IF we are in a sequence and it finished naturally, trigger NEXT
                    if (isCommitted && data.status === "Finished") {
                        nextCard();
                    } else if (data.status === "Stopped") {
                        // Manual Stop / AP
                        resetUI();
                    }
                }
            } catch (e) {}
        }

        // --- PLAYLIST LOGIC ---
        
        function nextCard() {
            const cards = Array.from(document.querySelectorAll('.card'));
            activeCardIndex++;
            
            if (activeCardIndex >= cards.length) {
                // End of Playlist
                speak("Regatta Sequence Complete.");
                resetUI();
                return;
            }
            
            const card = cards[activeCardIndex];
            
            // Highlight active card
            cards.forEach(c => c.style.borderLeftWidth = "5px");
            card.style.borderLeftWidth = "15px"; 
            
            // Check Type
            if (card.classList.contains('card-type-start')) {
                executeStartCard(card);
            } else {
                executeGapCard(card);
            }
        }
        
        function executeStartCard(card) {
            // Read Values
            const id = card.id.split('-')[1];
            currentClass = document.getElementById(`class-${id}`).value;
            if(currentClass === "None") currentClass = ""; 
            currentPrep = document.getElementById(`prep-${id}`).value;
            const orangeVal = document.getElementById(`orange-${id}`).value;
            orangeOffset = parseInt(orangeVal) * 60; 
            
            // Check Schedule (Only applies to the FIRST card if it has a time)
            const timeInput = document.getElementById(`time-${id}`).value;
            
            // If this is the FIRST card and has a time, we wait.
            // But if we are in the middle of a playlist (index > 0), we just go (unless time is set? No, playlist implies flow).
            // Simplified: If Time Input exists AND we are at index 0, we count down to it.
            if (activeCardIndex === 0 && timeInput) {
                startScheduleWatcher(timeInput);
                speak(`Sequence Armed for ${timeInput}`);
            } else {
                // Immediate Fire
                firePiSequence();
            }
        }
        
        function executeGapCard(card) {
            const id = card.id.split('-')[1];
            const durationVal = document.getElementById(`gap-${id}`).value;
            let seconds = parseInt(durationVal);
            
            if (seconds === 0) {
                // Rolling
                nextCard();
                return;
            }
            
            speak(`Gap. ${seconds/60} minutes.`);
            
            // Run Gap Timer on Phone
            let gapTime = seconds;
            updateTimers(gapTime); // Initial Show
            
            gapInterval = setInterval(() => {
                gapTime--;
                updateTimers(gapTime);
                
                // Voice for Gap (Simple)
                if(gapTime === 60) speak("One minute to next sequence.");
                if(gapTime === 10) speak("Ten seconds.");
                if(gapTime <= 5 && gapTime > 0) speak(gapTime.toString());
                
                if (gapTime <= 0) {
                    clearInterval(gapInterval);
                    nextCard(); // Move on
                }
            }, 1000);
        }

        // --- TIMING LOGIC ---

        function startScheduleWatcher(targetTimeStr) {
            if(scheduleInterval) clearInterval(scheduleInterval);
            
            // We need to countdown nicely
            scheduleInterval = setInterval(() => {
                const now = new Date();
                const nowStr = now.toTimeString().slice(0, 5); // "14:00"
                
                // Calculate seconds until target (for UI)
                const target = new Date();
                const [h, m] = targetTimeStr.split(':');
                target.setHours(h, m, 0, 0);
                
                let diff = Math.floor((target - now) / 1000);
                
                if (diff < 0) {
                    // Time passed? Fire immediately or handled?
                    clearInterval(scheduleInterval);
                    firePiSequence();
                } else {
                    // Update UI and Voice
                    updateTimers(diff);
                    
                    // Voice Triggers for Pre-Roll
                    // Note: 'diff' is time TO the start command.
                    // If orangeOffset is 0, Start Command = Warning Signal (300).
                    // So if diff = 60, we are 60s from Warning.
                    // We need to map 'diff' to the Regatta Time Scale.
                    
                    // The Regatta Scale: 
                    // Orange Start = 300 + orangeOffset.
                    // Warning = 300.
                    
                    // Actually, simpler:
                    // If we are waiting for a start time, that start time IS the trigger for the Pi.
                    // The Pi starts at (305 + orangeOffset).
                    // So 'diff' seconds before the Pi starts means we are 'diff' seconds before the First Horn.
                    
                    // Just count down 45, 30, 10 to the "Start of Sequence"
                     if ([45, 30, 20, 15, 10, 5, 4, 3, 2, 1].includes(diff)) {
                         let msg = "";
                         // What is the first event?
                         if (orangeOffset > 0) msg = "Orange Flag Display";
                         else msg = `${currentClass} Class Flag Display`;
                         
                         if(diff <= 5) speak(diff.toString());
                         else speak(`${diff} seconds to ${msg}`);
                     }
                }
            }, 1000);
        }

        function firePiSequence() {
            if(scheduleInterval) clearInterval(scheduleInterval);
            const duration = 305 + orangeOffset;
            sendCommand({ command: 'START_SEQUENCE', seconds: duration });
            speak("Sequence Initiated.");
        }

        // --- UI UPDATES ---

        function updateTimers(t) {
            if(t < 0) t = 0;
            const mins = Math.floor(t / 60);
            const secs = t % 60;
            document.getElementById('mainTimer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            // Next Signal Logic
            // If we are in Gap or Schedule mode, Next Signal is 0 (The start)
            if (gapInterval || scheduleInterval) {
                 document.getElementById('nextSignalTimer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
                 return;
            }

            // If running Pi logic
            let marks = [];
            if(orangeOffset > 0) marks.push(300 + orangeOffset);
            marks.push(300); marks.push(240); marks.push(60); marks.push(0);
            
            let nextMark = 0;
            for(let m of marks) {
                if (t > m) { nextMark = m; break; }
            }
            const diff = t - nextMark;
            const dMins = Math.floor(diff / 60);
            const dSecs = diff % 60;
            document.getElementById('nextSignalTimer').innerText = `${dMins}:${dSecs.toString().padStart(2, '0')}`;
        }

        function checkVoiceTriggers(t) {
            // Define Marks
            let marks = [];
            if (orangeOffset > 0) marks.push(300 + orangeOffset); 
            marks.push(300); marks.push(240); marks.push(60); marks.push(0);

            const triggers = [45, 30, 20, 15, 10, 5, 4, 3, 2, 1];

            marks.forEach(mark => {
                const diff = t - mark;
                if (diff >= 0 && diff < 300) {
                    if (diff === 0) {
                        if (mark > 300) speak("NOW! Orange Flag Display."); 
                        if (mark === 300) speak(`NOW! ${currentClass} Class Flag Display.`);
                        if (mark === 240) speak(`NOW! ${currentPrep} Flag Display.`);
                        if (mark === 60)  speak(`NOW! ${currentPrep} Flag Remove.`);
                        if (mark === 0)   speak(`NOW! ${currentClass} Class Flag Remove.`);
                    }
                    if (triggers.includes(diff)) {
                        let eventName = "";
                        if (mark > 300) eventName = "Orange Flag Display";
                        else if (mark === 300) eventName = `${currentClass} Class Flag Display`;
                        else if (mark === 240) eventName = `${currentPrep} Flag Display`;
                        else if (mark === 60)  eventName = `${currentPrep} Flag Remove`;
                        else if (mark === 0)   eventName = `${currentClass} Class Flag Remove`;

                        if (diff === 10) speak("10 seconds.");
                        else if (diff <= 5) speak(diff.toString());
                        else speak(`${diff} seconds to ${eventName}.`);
                    }
                }
            });
        }

        // --- BUTTONS & COMMANDS ---
        
        function toggleCommit() {
            if (!isCommitted) {
                // START / ARM
                const cards = document.querySelectorAll('.card');
                if(cards.length === 0) return;
                
                isCommitted = true;
                activeCardIndex = -1; // Reset
                
                document.getElementById('btnCommit').innerText = "SEQUENCE LOCKED IN. PRESS TO UNLOCK";
                document.getElementById('btnCommit').className = "btn-commit locked";
                cards.forEach(c => c.classList.add("locked"));
                
                nextCard(); // Start the first card logic
                
            } else {
                resetUI();
            }
        }
        
        function resetUI() {
             isCommitted = false;
             activeCardIndex = -1;
             if(gapInterval) clearInterval(gapInterval);
             if(scheduleInterval) clearInterval(scheduleInterval);
             gapInterval = null;
             scheduleInterval = null;
             
             document.getElementById('btnCommit').innerText = "COMMIT TO SEQUENCE";
             document.getElementById('btnCommit').className = "btn-commit unlocked";
             document.querySelectorAll('.card').forEach(c => {
                 c.classList.remove("locked");
                 c.style.borderLeftWidth = "5px";
             });
             
             sendCommand({ command: 'POSTPONE' }); // Ensure Pi stops
             speak("Sequence Reset.");
             document.getElementById('mainTimer').innerText = "00:00";
        }

        async function sendCommand(jsonObj) {
            if (!rxCharacteristic) return;
            await rxCharacteristic.writeValue(new TextEncoder().encode(JSON.stringify(jsonObj)));
        }

        function startNow() {
            // Immediate Start override
            // Ideally this injects an immediate start card or forces current card
            if(isCommitted && activeCardIndex >= 0) {
                // We are waiting for schedule?
                if(scheduleInterval) {
                    firePiSequence();
                }
            } else {
                 // Not committed? Just grab top card defaults and fire
                 // Simplified for safety: Start Now only valid if cards exist
                 alert("Please Commit a Sequence first, then wait for schedule or press Start Now to override timer.");
            }
        }
        
        function sendAP() { 
            resetUI();
        }
        
        function manualHorn(state) {
            state ? sendCommand({ command: 'HORN_ON' }) : sendCommand({ command: 'HORN_OFF' });
        }
        
        function downloadLog() { 
            logBuffer = ""; 
            sendCommand({ command: 'GET_LOG' }); 
        }

        function saveLogFile() {
            const blob = new Blob([logBuffer], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'race_log.csv';
            document.body.appendChild(a); a.click();
        }

        function updateTimeLabel(id) {
            const orangeVal = document.getElementById(`orange-${id}`).value;
            const label = document.getElementById(`time-label-${id}`);
            if (orangeVal === "0") {
                label.innerText = "Scheduled Warning Signal (Class Flag)";
                label.style.color = "#b0b0b0";
            } else {
                label.innerText = "Scheduled Orange Flag Display";
                label.style.color = "#ff9800";
            }
        }

        // --- CARD MANAGEMENT ---
        const stackEl = document.getElementById('sequence-stack');
        new Sortable(stackEl, { handle: '.drag-handle', animation: 150 });

        function addStartCard() {
            const id = cardIdCounter++;
            stackEl.insertAdjacentHTML('beforeend', `
                <div class="card card-type-start" id="c-${id}" style="border-left-color: var(--primary)">
                    <div class="card-header">
                        <div><span class="drag-handle">☰</span><span class="card-title">Start Sequence</span></div>
                        <button onclick="this.closest('.card').remove()" style="background:none;border:none;color:#666">✕</button>
                    </div>
                    <div class="form-row"><label>Class</label><select id="class-${id}"><option value="None">None (General)</option><option>Optimist Gold</option><option>Optimist Silver</option><option>ILCA 4</option><option>ILCA 6</option><option>ILCA 7</option><option>29er</option><option>49er</option><option>Techno293</option><option>Techno293Plus</option><option>iQ Foil</option><option>WingFoil</option><option>KiteFoil</option></select></div>
                    <div class="form-row"><label>Prep Flag</label><select id="prep-${id}"><option value="P">P (Blue)</option><option value="U">U (Red/White)</option><option value="Black">Black</option></select></div>
                    <div class="form-row"><label style="color:#ff9800">Orange Flag Sound</label><select id="orange-${id}" onchange="updateTimeLabel(${id})"><option value="0">No Orange Flag Needed</option><option value="1">1 Min before Class Flag</option><option value="4">4 Min before Class Flag</option><option value="5">5 Min before Class Flag</option></select></div>
                    <div class="form-row"><label id="time-label-${id}">Scheduled Warning Signal (Class Flag)</label><input type="time" id="time-${id}"></div>
                </div>`);
        }
        
        function addGapCard() {
            const id = cardIdCounter++;
            stackEl.insertAdjacentHTML('beforeend', `
                <div class="card" id="c-${id}" style="border-left-color: #ffc107">
                    <div class="card-header">
                        <div><span class="drag-handle">☰</span><span class="card-title">Gap / AP</span></div>
                        <button onclick="this.closest('.card').remove()" style="background:none;border:none;color:#666">✕</button>
                    </div>
                    <div class="form-row"><label>Duration</label><select id="gap-${id}"><option value="0">Immediate (Rolling)</option><option value="60">1 Min</option><option value="120">2 Min</option><option value="180">3 Min</option><option value="240">4 Min</option><option value="300">5 Min</option><option value="600">10 Min</option></select></div>
                </div>`);
        }

        addStartCard();
    </script>
</body>
</html>
